const posts = [
	{
		id: "1",
		url: "http://localhost:4000/2020/11/21/quickly-view-project-dependencies-on-the-cli.html",
		title: "Quickly view project dependencies on the cli",
		content_html: "<p>Ahnee! I frequently find myself on the command line wanting to know which dependencies and devDependencies are in the package.json file.</p>\n\n<p>I do it frequently enough that I decided to experiment with commander and create a command line utitlity in JavaScript/TypeScript.</p>\n\n<p><img src=\"/assets/img/screenshot-packages.png\" alt=\"packages screenshot\" /></p>\n\n<p>Check it out at <a href=\"https://github.com/jonesrussell/packages\">https://github.com/jonesrussell/packages</a> or simply:</p>\n\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>npm i <span class=\"nt\">-g</span> @jonesrussell42/packages\n</code></pre></div></div>\n\n<p>Meegwetch!</p>",
		summary: "Ahnee! I frequently find myself on the command line wanting to know which dependencies and devDependencies are in the package.json file.",
		date_published: "2020-11-21T00:00:00+00:00",
		date_modified: "2020-11-21T00:00:00+00:00",
		author: {
			name: "",
		},
		tags: ["cli", "web-development"],
	}, {
		id: "http://localhost:4000/browsers/2020/06/10/cant-view-saved-passwords-in-chrome",
		url: "http://localhost:4000/browsers/2020/06/10/cant-view-saved-passwords-in-chrome.html",
		title: "Can’t view saved passwords in Chrome",
		content_html: "<p>Ahnii! G’day.</p>\n\n<p>I tried to export my saved passwords from within Chrome and found what appears\nto be placeholder text where I expected to see passwords. Observe my\n[chrome://settings/passwords]:</p>\n\n<figure class=\"image\">\n  <img src=\"\" alt=\"Screenshot of Chrome settings with 'Saved passwords will appear here' message\" />\n  <figcaption>Saved passwords will appear here</figcaption>\n</figure>\n\n<h2 id=\"cause\">Cause</h2>\n\n<p>“Login Data” has become corrupted.</p>\n\n<h2 id=\"solution\">Solution</h2>\n\n<p>To fix we have to allow Chrome to regenerate “Login Data”.</p>\n\n<ol>\n  <li>Locate “Login Data” file</li>\n  <li>Shut down all instances of Chrome</li>\n  <li>Backup and remove “Login Data”</li>\n  <li>Start Chrome</li>\n  <li>Verify you can now view passwords</li>\n  <li>Jump for Joy :)</li>\n</ol>\n\n<h3 id=\"1-locate-login-data-file\">1. Locate “Login Data” file</h3>\n\n<p>In Chrome, type “chrome://version” into the address bar:</p>\n\n<p><img src=\"../assets/post/chrome-version-profile-path-1591453390495.png\" alt=\"chrome-version-profile-path\" /></p>\n\n<h3 id=\"2-shut-down-all-instances-of-chrome\">2. Shut down all instances of Chrome</h3>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pkill chrome\n</code></pre></div></div>\n\n<h3 id=\"3-backup-and-remove-login-data\">3. Backup and remove “Login Data”</h3>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">mkdir</span> <span class=\"nt\">-p</span> ~/.local/backups\n<span class=\"nb\">mv</span>\n</code></pre></div></div>\n\n<h3 id=\"4-start-chrome\">4. Start Chrome</h3>",
		summary: "Ahnii! G’day.",
		date_published: "2020-06-10T00:00:00+00:00",
		date_modified: "2020-06-10T00:00:00+00:00",
		author: {
			name: "",
		},
		tags: ["chrome", "passwords", "troubleshooting"],
	}, {
		id: "http://localhost:4000/web-development/2020/04/24/ddev-for-drupal",
		url: "http://localhost:4000/web-development/2020/04/24/ddev-for-drupal.html",
		title: "Use DDEV to locally develop with Drupal",
		content_html: "<p>I’ve been developing with Drupal for over 10 years. It’s never been known to be quick and easy to install, but with the rise of containers it’s now as easy as executing a few commands in a terminal.</p>\n\n<h2 id=\"prerequisites\">Prerequisites</h2>\n\n<p>Installing the prerequisites is beyond the scope of this post but here is a linked list of what you need installed on your system:</p>\n\n<ul>\n  <li><a href=\"https://getcomposer.org/download/\">Composer</a></li>\n  <li><a href=\"https://docs.docker.com/get-docker/\">Docker</a> version 18.06 or higher</li>\n  <li><a href=\"https://docs.docker.com/compose/install/\">Docker Compose</a></li>\n  <li><a href=\"https://ddev.readthedocs.io/en/latest/#installation\">DDEV</a></li>\n</ul>\n\n<h2 id=\"download--install-drupal\">Download &amp; Install Drupal</h2>\n\n<ol>\n  <li>\n    <p><em>composer</em> has become the de-facto standard package manager of PHP projects and the Drupal recommended way to manage a Drupal installation:</p>\n\n    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># use composer to download Drupal</span>\ncomposer create-project drupal/recommended-project my-drupal-site <span class=\"se\">\\</span>\n    <span class=\"o\">&amp;&amp;</span> <span class=\"nb\">cd</span> <span class=\"nv\">$_</span> <span class=\"c\"># $_ will contain 'my-drupal-site'</span>\n</code></pre></div>    </div>\n  </li>\n  <li>\n    <p><em>DDEV</em> is a wrapper for <em>Docker Compose</em> that spins up containers configured to serve PHP projects with an SQL database:</p>\n\n    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># create a ddev config and settings.php for Drupal</span>\nddev config <span class=\"nt\">--docroot</span> web <span class=\"nt\">--project-name</span> <span class=\"nv\">$_</span> <span class=\"nt\">--project-type</span> drupal8\n</code></pre></div>    </div>\n  </li>\n  <li>\n    <p>Start the containers:</p>\n\n    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ddev start\n</code></pre></div>    </div>\n\n    <p>Once the containers successfully start a link will be displayed to visit your site:</p>\n\n    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Successfully started my-drupal-site\nProject can be reached at http://my-drupal-site.ddev.site http://127.0.0.1:32780\n</code></pre></div>    </div>\n  </li>\n  <li>\n    <p>Before Drupal is usable it must be installed. You can click through the install wizard or use <em>drush</em>, a command-line utility for Drupal, that comes installed with <em>DDEV</em>:</p>\n\n    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ddev <span class=\"nb\">exec </span>drush site-install <span class=\"nt\">-y</span> <span class=\"nt\">--account-name</span><span class=\"o\">=</span>admin <span class=\"nt\">--account-pass</span><span class=\"o\">=</span>my-password\n</code></pre></div>    </div>\n  </li>\n</ol>\n\n<p>That’s it! Drupal is installed and running at <a href=\"http://my-drupal-site.ddev.site.\">http://my-drupal-site.ddev.site.</a></p>\n\n<h2 id=\"login\">Login</h2>\n\n<p>You can <a href=\"http://my-drupal-site.ddev.site/user/login\">login</a> with the following credentials:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>username: admin\npassword: my-password\n</code></pre></div></div>\n\n<h2 id=\"further-reading\">Further Reading</h2>\n\n<p>Documentation: <a href=\"https://ddev.readthedocs.io/en/latest/\">https://ddev.readthedocs.io/en/latest/</a></p>\n\n<p>DDEV includes some handy functionality, like running composer and <a href=\"https://www.drush.org/\">drush</a> within the web container to download and install new modules.</p>\n\n<p>You can easily import/export your database, or tap into <a href=\"https://ngrok.com/\">ngrok</a> to share a browse-able link to your project accessible from the internet.</p>\n\n<p>Happy developing! Gabekana.</p>",
		summary: "I’ve been developing with Drupal for over 10 years. It’s never been known to be quick and easy to install, but with the rise of containers it’s now as easy as executing a few commands in a terminal.",
		date_published: "2020-04-24T00:00:00+00:00",
		date_modified: "2020-04-24T00:00:00+00:00",
		author: {
			name: "",
		},
		tags: ["drupal", "docker", "devops", "php"],
	}, {
		id: "http://localhost:4000/mildly-interesting/2018/10/25/whalebrew",
		url: "http://localhost:4000/mildly-interesting/2018/10/25/whalebrew.html",
		title: "Whalebrew",
		content_html: "<h4>Docker Images as ‘Native’ Commands</h4>\n<p>\n  Ahnee! If you’re from the Mac World you’ve probably used, or at least heard of,\n  <a href=\"https://brew.sh/\">Homebrew</a>. For the uninformed, Homebrew is\n  <em>The missing package manager for macOS. </em>Or more accurately it’s a package management system for macOS that’s\n  comparable to Redhat’s <a href=\"http://rpm.org/\">RPM</a>, Debian’s <a href=\"https://wiki.debian.org/Apt\">APT</a>, and\n  Window’s <a href=\"https://chocolatey.org/\">Chocolatey</a>.\n</p>\n<p>\n  Package managers make installing software easy by automagically fetching a pre-compiled binary and its dependencies,\n  then copying them into your $PATH.\n</p>\n<p>\n  Depending on the software, compiling from source code is often difficult and time-consuming. Package managers let you\n  get on with the using the software.\n</p>\n<h3>Installing With APT</h3>\n<figure>\n  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*MLwvtPEG0yoOEtCzml-R9Q.png\" />\n  <figcaption>figlet displays large characters made up of ordinary screen characters</figcaption>\n</figure>\n<p>I’ll demonstrate installing a package with APT in Ubuntu 18.10:</p>\n<pre><strong>$</strong> sudo apt install figlet</pre>\n<p>\n  As you can see in the screenshot, APT downloads the figlet package (figlet_2.2.5–3_amd64.deb), unpacks it, then\n  finally installs to /usr/bin/figlet.\n</p>\n<pre><strong>$</strong> figlet &quot;p4ck4g3&#39;s 4 l1fe\\!&quot;</pre>\n<figure>\n  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*XkvZZOmATGe8p6Ri2ZqOaA.png\" />\n  <figcaption>figlet in action</figcaption>\n</figure>\n<h3>I Whale Always Love You</h3>\n<p>\n  Whalebrew is an inevitable side effect of container proliferation. Their ease of use, speed, and low resource\n  consumption make them ideal vehicles for single command or function execution.\n</p>\n<p>\n  As I’ve\n  <a href=\"https://medium.com/@jonesrussell42/docker-for-legacy-drupal-development-6df4dec8b309#b965\"\n    >previously written</a\n  >, containers can be started, perform a task, then stopped in a matter of milliseconds. And that’s exactly what\n  Whalebrew allows you to do in the form of Docker images aliased in your $PATH.\n</p>\n<p>Now let’s put a magnifying glass up to Whalebrew by walking through its installation then “install a package”.</p>\n<h3>Whalebrew Demonstration</h3>\n<p>\n  By creating an alias for running a Docker container and storing it in $PATH, running a command within a container is\n  seamless and virtually indistinguishable from running a command directly in the environment.\n</p>\n<p>\n  What does that look like exactly? Assuming you already have\n  <a href=\"https://medium.com/@jonesrussell42/docker-for-legacy-drupal-development-6df4dec8b309#db40\"\n    >Docker installed</a\n  >, we’ll start by installing Whalebrew (from\n  <a href=\"https://github.com/bfirsh/whalebrew\">https://github.com/bfirsh/whalebrew</a>):\n</p>\n<pre><strong>$</strong> sudo curl -L &quot;https://github.com/bfirsh/whalebrew/releases/download/0.1.0/whalebrew-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/whalebrew; sudo chmod +x /usr/local/bin/whalebrew</pre>\n<figure>\n  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*EzjhwX8SPJ-Zlcjxiayt2A.png\" />\n  <figcaption>Whalebrew installed to /usr/local/bin/whalebrew</figcaption>\n</figure>\n<p>Now let’s install figlet again, but this time with Whalebrew:</p>\n<pre><strong>$</strong> sudo whalebrew install whalebrew/figlet</pre>\n<figure>\n  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*bLCbFgBYsdCcLfeKnr2UpA.png\" />\n  <figcaption>whalebrew/figlet installed to /usr/local/bin/figlet</figcaption>\n</figure>\n<p>\n  Now let’s run figlet again and adore the glorious results (We’ll use the full path in case the APT figlet is first\n  in $PATH):\n</p>\n<pre><strong>$</strong> /usr/local/bin/figlet &quot;It&#39;s a whale of a time\\!&quot;</pre>\n<figure>\n  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*X8Eew1wrMcMjbw2-skNPGQ.png\" />\n  <figcaption>figlet as run in a Docker container</figcaption>\n</figure>\n<p>\n  Tada! We’ve just run figlet from within a container. You may have noticed it took a bit longer to execute, depending\n  on your computer’s <em>runtime juice</em>.\n</p>\n<p>\n  So what just happened? Before we wrap it up we’ll take a quick look under the hood and examine the difference between\n  running a native binary and a Whalebrew command.\n</p>\n<h3>Native vs. ‘Native’</h3>\n<figure>\n  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*zpAHqMDHdy4hqXN3fo1hAQ.jpeg\" />\n  <figcaption>\n    <a href=\"http://bibliodyssey.blogspot.com/2006/08/bodmer-series-on-native-america.html\"\n      >Facsimile of an Indian Painting</a\n    >\n  </figcaption>\n</figure>\n<p>\n  Maazhichige, wrong ‘native’! The figlet program installed with APT is an ELF executable, the\n  <a href=\"https://github.com/cmatsuoka/figlet\">source code</a> compiled from C, and it runs directly on your system.\n</p>\n<p>The Whalebrew alias looks like this:</p>\n<pre><strong>$</strong> cat /usr/local/bin/figlet</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*zMYeFQLlnwjjhttXCnVGiw.png\" /></figure>\n<blockquote>\n  When a package is executed, Whalebrew will run the specified image with Docker, mount the current working directory in\n  /workdir, and pass through all of the arguments.\n</blockquote>\n<p>And this is essentially what Whalebrew executes:</p>\n<pre><strong>$</strong> docker run -it -v &quot;$(pwd)&quot;:/workdir -w /workdir whalebrew/figlet &quot;It&#39;s a whale of a time\\!&quot;</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*lSmdCGIGlEE6KDWGBHfFMA.png\" /></figure>\n<p>And well, that’s it, move along. Baamaapii.</p>\n<img\n  src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9c3535b3c722\"\n  width=\"1\"\n  height=\"1\"\n/>",
		summary: "Docker Images as ‘Native’ Commands Ahnee! If you’re from the Mac World you’ve probably used, or at least heard of, Homebrew. For the uninformed, Homebrew is The missing package manager for macOS. Or more accurately it’s a package management system for macOS that’s comparable to Redhat’s RPM, Debian’s APT, and Window’s Chocolatey. Package managers make installing software easy by automagically fetching a pre-compiled binary and its dependencies, then copying them into your $PATH. Depending on the software, compiling from source code is often difficult and time-consuming. Package managers let you get on with the using the software. Installing With APT figlet displays large characters made up of ordinary screen characters I’ll demonstrate installing a package with APT in Ubuntu 18.10: $ sudo apt install figlet As you can see in the screenshot, APT downloads the figlet package (figlet_2.2.5–3_amd64.deb), unpacks it, then finally installs to /usr/bin/figlet. $ figlet &quot;p4ck4g3&#39;s 4 l1fe\\!&quot; figlet in action I Whale Always Love You Whalebrew is an inevitable side effect of container proliferation. Their ease of use, speed, and low resource consumption make them ideal vehicles for single command or function execution. As I’ve previously written, containers can be started, perform a task, then stopped in a matter of milliseconds. And that’s exactly what Whalebrew allows you to do in the form of Docker images aliased in your $PATH. Now let’s put a magnifying glass up to Whalebrew by walking through its installation then “install a package”. Whalebrew Demonstration By creating an alias for running a Docker container and storing it in $PATH, running a command within a container is seamless and virtually indistinguishable from running a command directly in the environment. What does that look like exactly? Assuming you already have Docker installed, we’ll start by installing Whalebrew (from https://github.com/bfirsh/whalebrew): $ sudo curl -L &quot;https://github.com/bfirsh/whalebrew/releases/download/0.1.0/whalebrew-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/whalebrew; sudo chmod +x /usr/local/bin/whalebrew Whalebrew installed to /usr/local/bin/whalebrew Now let’s install figlet again, but this time with Whalebrew: $ sudo whalebrew install whalebrew/figlet whalebrew/figlet installed to /usr/local/bin/figlet Now let’s run figlet again and adore the glorious results (We’ll use the full path in case the APT figlet is first in $PATH): $ /usr/local/bin/figlet &quot;It&#39;s a whale of a time\\!&quot; figlet as run in a Docker container Tada! We’ve just run figlet from within a container. You may have noticed it took a bit longer to execute, depending on your computer’s runtime juice. So what just happened? Before we wrap it up we’ll take a quick look under the hood and examine the difference between running a native binary and a Whalebrew command. Native vs. ‘Native’ Facsimile of an Indian Painting Maazhichige, wrong ‘native’! The figlet program installed with APT is an ELF executable, the source code compiled from C, and it runs directly on your system. The Whalebrew alias looks like this: $ cat /usr/local/bin/figlet When a package is executed, Whalebrew will run the specified image with Docker, mount the current working directory in /workdir, and pass through all of the arguments. And this is essentially what Whalebrew executes: $ docker run -it -v &quot;$(pwd)&quot;:/workdir -w /workdir whalebrew/figlet &quot;It&#39;s a whale of a time\\!&quot; And well, that’s it, move along. Baamaapii.",
		date_published: "2018-10-25T00:00:00+00:00",
		date_modified: "2018-10-25T00:00:00+00:00",
		author: {
			name: "",
		},
		tags: ["docker", "linux"],
	}, {
		id: "http://localhost:4000/devops/2018/10/14/docker-for-legacy-drupal-development",
		url: "http://localhost:4000/devops/2018/10/14/docker-for-legacy-drupal-development.html",
		title: "Docker for Legacy Drupal Development",
		content_html: "<h4>Leveraging Linux containers for Migrating Drupal 6 to Drupal 8</h4>\n<p>\n  Ahnee. Let me start by saying this article/tutorial (artorial, tutarticle!?), this <em>artorial </em>could be titled\n  “<strong>Docker for Development</strong>, <em>Leveraging Linux containers</em>” and be applied to virtually any stack\n  you want.\n</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*s-YgL1NW7evYyCBWI-7w8Q.png\" /></figure>\n<p>I’m using Drupal because I recently began a Drupal 6 (D6) to Drupal 8 (D8) website migration.</p>\n<blockquote>\n  Drupal is a free, open-source content management system (CMS) with a large, supportive community. It’s used by\n  millions of people and organizations around the globe to build and maintain their websites.\n</blockquote>\n<p>\n  Both versions run on a LAMP stack but with different versions of PHP. D6 reached it’s end-of-life in early 2016,\n  almost a year before PHP 7 was released. Consequently it requires PHP 5.6 and lower to run.\n</p>\n<p>\n  <em>The folks at </em\n  ><a href=\"https://www.mydropwizard.com/blog/drupal-6-year-2020-and-php-7-support\"><em>myDropWizard.com</em></a\n  ><em>\n    are bravely supporting D6 until the cows come home, props to them! I have no affiliation with them, I’m just\n    thunderstruck by their </em\n  ><a href=\"https://www.mydropwizard.com/blog/drupal-6-2019-yes-really\"><em>level of commitment</em></a\n  ><em>.</em>\n</p>\n<p>\n  According to the docs D8 will run on PHP 5.5.9+, but any version less than 7.1 is\n  <a href=\"https://www.drupal.org/docs/8/system-requirements/php-requirements#php_required\">not recommended</a>.\n  <strong>If running Drupal 8 on PHP 5.6 you go, only pain will you find</strong>.\n</p>\n<p>\n  So how do you run PHP 5 and PHP 7 simultaneously on the same host? Spin up a pair of VMs?\n  <a href=\"https://www.tecmint.com/install-different-php-versions-in-ubuntu/\"\n    >Slip in Nginx and PHP-FPM alongside Apache</a\n  >? The former option is acceptable. The latter borders on sadomasochism.\n</p>\n<figure>\n  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/244/1*4jh-4MnN2NkYxWZVOKBklw.jpeg\" />\n  <figcaption>And there is, Kevin!</figcaption>\n</figure>\n<p>The answer is, of course, Docker.</p>\n<h3>This Guy’s Setup</h3>\n<p>\n  I use Linux as my primary Operating System (OS). Ubuntu 18.04 loaded with the latest packages of Apache 2.4, MySQL\n  5.7, and PHP 7.2 from Ubuntu’s official repositories.\n</p>\n<h4>Drupal 8</h4>\n<p>\n  My Ubuntu host is similar enough to the production environment where D8 is to be deployed that I created an Apache\n  Virtual Host (vhost) and MySQL database then\n  <a\n    href=\"https://www.drupal.org/docs/develop/using-composer/using-composer-to-manage-drupal-site-dependencies#download-core-option-a\"\n    >downloaded D8 using a composer template</a\n  >\n  and installed it with <a href=\"https://docs.drupalconsole.com/en/commands/site-install.html\">Drupal Console</a>.\n</p>\n<blockquote>\n  What is the Drupal Console? The Drupal CLI. A tool to generate boilerplate code, interact with and debug Drupal. From\n  the ground up, it has been built to utilize the same modern PHP practices which were introduced in Drupal 8.\n</blockquote>\n<h4>Drupal 6</h4>\n<p>This is where the fun begins. But first I’ll explain the differences between a VM and a Container.</p>\n<h3>VMs and Containers Compared</h3>\n<h4>VM</h4>\n<p>\n  There are many VM providers. <a href=\"https://www.virtualbox.org/\">VirtualBox</a>,\n  <a href=\"https://www.qemu.org/\">QEMU</a>, and <a href=\"https://www.vmware.com/\">VMWare</a> to name a few. A VM\n  contains a full OS and <a href=\"https://en.wikipedia.org/wiki/Kernel_(operating_system)\">kernel</a> running in\n  isolation (so lonely) from the host. It is indistinguishable from a proper desktop or server.\n</p>\n<p>\n  Before booting, VMs are allocated resources such as RAM and CPU cores. The VM provides a hardware emulation layer\n  between the guest OS and the host, which looks and feels like bare metal as far as the guest OS is concerned.\n</p>\n<p>\n  Because they resemble physical desktops and servers, VMs require significant amounts of the host’s system resources.\n  In contrast to Containers this severely limits the amount of VMs that can run concurrently on a single host. The\n  boot-up and shutdown time is also the same as a physical machine; another significant difference.\n</p>\n<h4>Containers</h4>\n<p>\n  Containers offer the advantages of VMs without the overhead. By virtualizing at the kernel level containers share\n  resources with the host. Many more containers can run simultaneously on a single machine compared to VMs.\n</p>\n<p>\n  Containers worry more about resource prioritization rather than resource allocation. In other words, a container says\n  “When will you run this process for me niijikiwenh?” rather than “How much CPU do I have to run this process?”.\n</p>\n<p>\n  Finally, starting up or shutting down a Container is super fast <em>*whoooooosh*</em>. Because Containers share a\n  fully loaded kernel with the host, they can be started, perform a task, then shut down within milliseconds. Containers\n  are the mayflies of the tech world. On the flip side, they can last until an act of God brings them down along with\n  your house.\n</p>\n<h4>Docker</h4>\n<p>I messed with Docker years ago but only recently gave it a prime time slot in my regularly scheduled programming.</p>\n<p>\n  Docker makes it easier to create, deploy, and run an application in a lightweight and portable Container by packaging\n  it up with it’s dependencies and shipping them out as an image.\n</p>\n<p>\n  I’ve only skimmed the surface of Docker and don’t fully understand how it works under the hood. I’m also anxious to\n  check out a competitor such as <a href=\"http://www.ubuntu.org.cn/cloud/lxd\">Canonical’s LXD</a> or\n  <a href=\"https://coreos.com/rkt/\">CoreOS/Redhat’s Rkt</a>. All in good time.\n</p>\n<h4>Docker Images</h4>\n<p>\n  Docker loads an image containing an OS and the software needed to do a job into a container. In other words, an image\n  contains your applications runtime environment.\n</p>\n<p>\n  Creating an image is rather painless, depending on the complexity of your requirements. You write a set of\n  instructions in YAML saved as a Dockerfile, then run docker build. Our tutorial requirements are simple and can be met\n  with pre-existing images pulled from <a href=\"https://hub.docker.com/\">Docker Hub</a>, a Docker image\n  registry service.\n</p>\n<p>\n  While I can find an image which contains Apache, PHP, and MySQL all together, we’re going to follow\n  <a href=\"https://devops.stackexchange.com/questions/447/why-it-is-recommended-to-run-only-one-process-in-a-container\"\n    >best practices</a\n  >\n  and separate the web server from the database into 2 containers where they will communicate through an internal subnet\n  created by Docker.\n</p>\n<h4>Persisting Data</h4>\n<p>\n  Finally, containers are designed to be disposable, with the ability to run as a single instance on a single host, or\n  to be scaled as multiple instances distributed over server clusters. By default, data is written to a containers\n  writable layer and will be disposed of along with the container.\n</p>\n<p>\n  Volumes and Bind Mounts are Dockers two options for persisting data. I can, and maybe will, write an entire post to\n  fully explain them. But to keep it brief I will say Volumes are managed by Docker, isolated from the host, can be\n  mounted into multiple containers, and stored on remote hosts or in a cloud provider.\n</p>\n<p>\n  Bind Mounts are a file or directory on the host machine mounted into a container. They are a good option to share\n  configuration data, source code, and build artifacts during development. In production, your build artifacts are best\n  copied directly into the image, configuration in the environment, and source code unnecessary.\n</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/740/1*W49kEOLhKZTuC9DmRKD6Qg.png\" /></figure>\n<p>\n  Volumes are recommended for storing data used and generated by containers. Bind mounts depend on the host machine’s\n  directory structure, hampering container portability.\n</p>\n<p>In this tutorial we will get by with a bind mount.</p>\n<h3>Summary</h3>\n<p>\n  That’s Docker so far as I understand it. I hope you find it beneficial and are encouraged to begin developing with\n  Docker. I invite you to join in on the fun below and follow the step-by-step instructions to get down and dirty\n  with Docker.\n</p>\n<h3>Tutorial</h3>\n<p>\n  Let’s setup Drupal 6 within containers in Ubuntu. If you are not using Ubuntu don’t fret, the only step you need to\n  change is “Install Docker”. In that case refer to\n  <a href=\"https://docs.docker.com/install/#supported-platforms\"\n    >https://docs.docker.com/install/#supported-platforms</a\n  >\n  for instructions to install Docker on your OS.\n</p>\n<p>If you catch any mistakes or see room for improvement please contact me. Otherwise, wacka wacka.</p>\n<h4>Prerequisites</h4>\n<p>\n  sudo (or root) — Required to install and run Docker. To run docker commands without sudo or root you must add your\n  user account to the <em>docker</em> group.\n</p>\n<h4>Table of Contents</h4>\n<ol>\n  <li>Install Docker</li>\n  <li>Add user to docker group</li>\n  <li>Start Docker</li>\n  <li>Pull MySQL image</li>\n  <li>Start container</li>\n  <li>Download Drupal 6</li>\n  <li>Pull Apache/PHP image</li>\n  <li>Enable mod_rewrite</li>\n  <li>Allow Overrides</li>\n  <li>Start container with a bind mount</li>\n  <li>Install Drupal</li>\n  <li>Cleanup</li>\n</ol>\n<p>Biminizha’.</p>\n<h4>Install Docker</h4>\n<p>Open a terminal and ensure your package lists are up to date then install Docker (aka Docker Engine):</p>\n<pre>$ sudo apt update<br>$ sudo apt install docker.io -y</pre>\n<p><em>Output:</em></p>\n<pre>&lt;heaps of output&gt;<br>Processing triggers for systemd (237-3ubuntu10.3) ...</pre>\n<p>Docker Engine is comprised of three major components:</p>\n<ul>\n  <li><em>dockerd</em> (Server) — a daemon that is a long-running background process</li>\n  <li><em>docker</em> (Client) — a command line interface</li>\n  <li>REST API — specifies interfaces that programs can use to communicate with the daemon</li>\n</ul>\n<h4>Start Docker</h4>\n<p>Kick-start the aforementioned long-running background process:</p>\n<pre>$ sudo systemctl start docker</pre>\n<p>Optionally, tell <em>systemd</em> to start docker on system boot:</p>\n<pre>$ sudo systemctl enable docker</pre>\n<p>Docker is now installed and ready for use. Check if docker is running:</p>\n<pre>$ systemctl is-active docker</pre>\n<p><em>Output:</em></p>\n<pre>active</pre>\n<h4>Pull MySQL image</h4>\n<p>\n  Now that you have docker running you can pull your first image. Start with\n  <a href=\"https://hub.docker.com/r/mysql/mysql-server/\">MySQL</a> version 5.6 (without <em>:5.6</em> specified, :<em\n    >latest</em\n  >\n  is implied):\n</p>\n<pre>$ sudo docker pull mysql:5.6</pre>\n<p><em>Output:</em></p>\n<pre>5.6: Pulling from library/mysql<br>802b00ed6f79: Pull complete <br>30f19a05b898: Pull complete <br>3e43303be5e9: Pull complete <br>94b281824ae2: Pull complete <br>51eb397095b1: Pull complete <br>3f6fe5e46bae: Pull complete <br>b5a334ca6427: Pull complete <br>115764d35d7a: Pull complete <br>719bba2efabc: Pull complete <br>284e66788ee1: Pull complete <br>0f085ade122c: Pull complete <br>Digest: sha256:4c44f46efaff3ebe7cdc7b35a616c77aa003dc5de4b26c80d0ccae1f9db4a372<br>Status: Downloaded newer image for mysql:5.6</pre>\n<h3>Start MySQL</h3>\n<p>Start the DB container, options are explained below:</p>\n<pre>$ sudo docker run -d \\<br>--name=&quot;drupal-mysql&quot; \\<br>-e MYSQL_ROOT_PASSWORD=drupalroot \\<br>-e MYSQL_DATABASE=drupal6 \\<br>-e MYSQL_USER=drupal \\<br>-e MYSQL_PASSWORD=drupal6pass \\<br>mysql:5.6</pre>\n<ul>\n  <li>-d — Start the container as a background process.</li>\n  <li>--name —Will be referenced during Drupal install. A random name will be assigned if one isn’t provided.</li>\n  <li>\n    -e — Set’s an environment variable. MySQL will be configured with\n    <a href=\"https://hub.docker.com/_/mysql/\">values passed in</a> by the environment.\n  </li>\n</ul>\n<p><em>Output (will differ):</em></p>\n<pre>de99c912e3fbeb4f113889c145b5fab82787259c21d51962c9186e90c27d2857</pre>\n<h4>Download Drupal 6</h4>\n<p>\n  D6 is available for download from the official Drupal site packaged as a gzipped tarball. You can grab it with wget:\n</p>\n<pre>$ cd ~<br>$ wget <a href=\"https://ftp.drupal.org/files/projects/drupal-6.38.tar.gz\">https://ftp.drupal.org/files/projects/drupal-6.38.tar.gz</a><br>$ tar -xzf drupal-6.38.tar.gz</pre>\n<p>Verify drupal-6.38 exists in your home directory:</p>\n<pre>$ if test -d ~/drupal-6.38; then echo “It exists”; fi</pre>\n<p><em>Output:</em></p>\n<pre>It exists</pre>\n<h4>Pull Apache/PHP image</h4>\n<p>\n  Now pull a docker image of Ubuntu 14.04 LTS with Apache 2, PHP 5, and Composer from\n  <a href=\"https://hub.docker.com/r/nimmis/apache-php5/:\">https://hub.docker.com/r/nimmis/apache-php5/:</a>\n</p>\n<pre>$ sudo docker pull nimmis/apache-php5</pre>\n<p><em>Output:</em></p>\n<pre>Using default tag: latest<br>latest: Pulling from nimmis/apache-php5<br>c2c80a08aa8c: Pull complete <br>6ace04d7a4a2: Pull complete <br>f03114bcfb25: Pull complete <br>99df43987812: Pull complete <br>9c646cd4d155: Pull complete <br>5c017123b62e: Pull complete <br>8f95d9abec41: Pull complete <br>c46de42c66c3: Pull complete <br>9a19620cecad: Pull complete <br>5c62abdf642f: Pull complete <br>Digest: sha256:712d35d5cc30e6a911e260e871f08f77d5684edcc50cba21163535714c547ff5<br>Status: Downloaded newer image for nimmis/apache-php5:latest</pre>\n<h4>DocumentRoot and Incoming Port</h4>\n<p>\n  The containerized Apache’s default DocumentRoot is /var/www/html, which we will bind mount to the D6 files in\n  ~/drupal-6.38.\n</p>\n<p>\n  Because I already have Apache on the host I have to bind the container’s port 80 to something else. I’m using 10080\n  but you can choose almost any other free port.\n</p>\n<pre>$ sudo docker run -d  \\<br>-p 10080:80 \\<br>-v ~/drupal-6.38:/var/www/html \\<br>--name=&quot;drupal-app&quot; \\<br>--link=&quot;drupal-mysql&quot; \\<br>nimmis/apache-php5</pre>\n<p><em>Output:</em></p>\n<pre>0398890ab8e0a082f68373c8e7fd088e925f9bac0eca178399b883091919ee77</pre>\n<p>An explanation of what’s between run and nimmis/apache-php5:</p>\n<ul>\n  <li>-d — Daemonize, run in background.</li>\n  <li>-p 10080:80 — Bind host port 10080 to container port 80.</li>\n  <li>-v ~/drupal-6.38:/var/www/html — Bind host directory to container directory.</li>\n  <li>— name=&quot;drupal-app&quot; — Name the container instance for convenience.</li>\n  <li>--link=&quot;drupal-mysql&quot; — Link to the MySQL container so Drupal can communicate with the database.</li>\n</ul>\n<h4>Install Drupal</h4>\n<p>\n  Open <a href=\"http://localhost:10080\">http://localhost:10080</a> in a browser (<em\n    >xdg-open is a program that will open a file or URL in the preferred application as set in your OS</em\n  >):\n</p>\n<pre>$ xdg-open <a href=\"http://localhost:10080\">http://localhost:10080</a></pre>\n<p>Tada! The Drupal 6 installation page should be open in a browser, served from within a set of Docker containers.</p>\n<p>\n  To complete the installation use the database name (<em>drupal6</em>), username (<em>drupal</em>), and password\n  (<em>drupal6pass</em>) as set in the <em>Start MySQL</em> step. Under <em>Advanced Options</em>, set the\n  <em>Database host</em> to the name of your MySQL container, <em>drupal-mysql</em>.\n</p>\n<h3>Cleanup</h3>\n<p>When you have finished with Drupal 6 shut down the containers and delete them from the host.</p>\n<p>Stop the containers:</p>\n<pre>$ sudo docker container stop drupal-app drupal-mysql</pre>\n<p><em>Output:</em></p>\n<pre>drupal-app<br>drupal-mysql</pre>\n<p>Remove the containers:</p>\n<pre>$ sudo docker container rm drupal-app drupal-mysql</pre>\n<p><em>Output:</em></p>\n<pre>drupal-app<br>drupal-mysql</pre>\n<p>Verify the containers have been deleted:</p>\n<pre>$ sudo docker container ls</pre>\n<p>That’s it, move along. Baamaapii.</p>\n<h3>Bonus: <em>docker</em> group</h3>\n<p>To display a list of groups you belong to is simple:</p>\n<pre>$ group</pre>\n<p><em>Output:</em></p>\n<pre>roosta adm cdrom sudo dip plugdev lpadmin sambashare</pre>\n<p>Add your user account to the <em>docker</em> group:</p>\n<pre>$ sudo usermod -aG docker $USER</pre>\n<p>You must log out then log back in before it takes effect.</p>\n<img\n  src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6df4dec8b309\"\n  width=\"1\"\n  height=\"1\"\n/>",
		summary: "Leveraging Linux containers for Migrating Drupal 6 to Drupal 8 Ahnee. Let me start by saying this article/tutorial (artorial, tutarticle!?), this artorial could be titled “Docker for Development, Leveraging Linux containers” and be applied to virtually any stack you want. I’m using Drupal because I recently began a Drupal 6 (D6) to Drupal 8 (D8) website migration. Drupal is a free, open-source content management system (CMS) with a large, supportive community. It’s used by millions of people and organizations around the globe to build and maintain their websites. Both versions run on a LAMP stack but with different versions of PHP. D6 reached it’s end-of-life in early 2016, almost a year before PHP 7 was released. Consequently it requires PHP 5.6 and lower to run. The folks at myDropWizard.com are bravely supporting D6 until the cows come home, props to them! I have no affiliation with them, I’m just thunderstruck by their level of commitment. According to the docs D8 will run on PHP 5.5.9+, but any version less than 7.1 is not recommended. If running Drupal 8 on PHP 5.6 you go, only pain will you find. So how do you run PHP 5 and PHP 7 simultaneously on the same host? Spin up a pair of VMs? Slip in Nginx and PHP-FPM alongside Apache? The former option is acceptable. The latter borders on sadomasochism. And there is, Kevin! The answer is, of course, Docker. This Guy’s Setup I use Linux as my primary Operating System (OS). Ubuntu 18.04 loaded with the latest packages of Apache 2.4, MySQL 5.7, and PHP 7.2 from Ubuntu’s official repositories. Drupal 8 My Ubuntu host is similar enough to the production environment where D8 is to be deployed that I created an Apache Virtual Host (vhost) and MySQL database then downloaded D8 using a composer template and installed it with Drupal Console. What is the Drupal Console? The Drupal CLI. A tool to generate boilerplate code, interact with and debug Drupal. From the ground up, it has been built to utilize the same modern PHP practices which were introduced in Drupal 8. Drupal 6 This is where the fun begins. But first I’ll explain the differences between a VM and a Container. VMs and Containers Compared VM There are many VM providers. VirtualBox, QEMU, and VMWare to name a few. A VM contains a full OS and kernel running in isolation (so lonely) from the host. It is indistinguishable from a proper desktop or server. Before booting, VMs are allocated resources such as RAM and CPU cores. The VM provides a hardware emulation layer between the guest OS and the host, which looks and feels like bare metal as far as the guest OS is concerned. Because they resemble physical desktops and servers, VMs require significant amounts of the host’s system resources. In contrast to Containers this severely limits the amount of VMs that can run concurrently on a single host. The boot-up and shutdown time is also the same as a physical machine; another significant difference. Containers Containers offer the advantages of VMs without the overhead. By virtualizing at the kernel level containers share resources with the host. Many more containers can run simultaneously on a single machine compared to VMs. Containers worry more about resource prioritization rather than resource allocation. In other words, a container says “When will you run this process for me niijikiwenh?” rather than “How much CPU do I have to run this process?”. Finally, starting up or shutting down a Container is super fast *whoooooosh*. Because Containers share a fully loaded kernel with the host, they can be started, perform a task, then shut down within milliseconds. Containers are the mayflies of the tech world. On the flip side, they can last until an act of God brings them down along with your house. Docker I messed with Docker years ago but only recently gave it a prime time slot in my regularly scheduled programming. Docker makes it easier to create, deploy, and run an application in a lightweight and portable Container by packaging it up with it’s dependencies and shipping them out as an image. I’ve only skimmed the surface of Docker and don’t fully understand how it works under the hood. I’m also anxious to check out a competitor such as Canonical’s LXD or CoreOS/Redhat’s Rkt. All in good time. Docker Images Docker loads an image containing an OS and the software needed to do a job into a container. In other words, an image contains your applications runtime environment. Creating an image is rather painless, depending on the complexity of your requirements. You write a set of instructions in YAML saved as a Dockerfile, then run docker build. Our tutorial requirements are simple and can be met with pre-existing images pulled from Docker Hub, a Docker image registry service. While I can find an image which contains Apache, PHP, and MySQL all together, we’re going to follow best practices and separate the web server from the database into 2 containers where they will communicate through an internal subnet created by Docker. Persisting Data Finally, containers are designed to be disposable, with the ability to run as a single instance on a single host, or to be scaled as multiple instances distributed over server clusters. By default, data is written to a containers writable layer and will be disposed of along with the container. Volumes and Bind Mounts are Dockers two options for persisting data. I can, and maybe will, write an entire post to fully explain them. But to keep it brief I will say Volumes are managed by Docker, isolated from the host, can be mounted into multiple containers, and stored on remote hosts or in a cloud provider. Bind Mounts are a file or directory on the host machine mounted into a container. They are a good option to share configuration data, source code, and build artifacts during development. In production, your build artifacts are best copied directly into the image, configuration in the environment, and source code unnecessary. Volumes are recommended for storing data used and generated by containers. Bind mounts depend on the host machine’s directory structure, hampering container portability. In this tutorial we will get by with a bind mount. Summary That’s Docker so far as I understand it. I hope you find it beneficial and are encouraged to begin developing with Docker. I invite you to join in on the fun below and follow the step-by-step instructions to get down and dirty with Docker. Tutorial Let’s setup Drupal 6 within containers in Ubuntu. If you are not using Ubuntu don’t fret, the only step you need to change is “Install Docker”. In that case refer to https://docs.docker.com/install/#supported-platforms for instructions to install Docker on your OS. If you catch any mistakes or see room for improvement please contact me. Otherwise, wacka wacka. Prerequisites sudo (or root) — Required to install and run Docker. To run docker commands without sudo or root you must add your user account to the docker group. Table of Contents Install Docker Add user to docker group Start Docker Pull MySQL image Start container Download Drupal 6 Pull Apache/PHP image Enable mod_rewrite Allow Overrides Start container with a bind mount Install Drupal Cleanup Biminizha’. Install Docker Open a terminal and ensure your package lists are up to date then install Docker (aka Docker Engine): $ sudo apt update$ sudo apt install docker.io -y Output: &lt;heaps of output&gt;Processing triggers for systemd (237-3ubuntu10.3) ... Docker Engine is comprised of three major components: dockerd (Server) — a daemon that is a long-running background process docker (Client) — a command line interface REST API — specifies interfaces that programs can use to communicate with the daemon Start Docker Kick-start the aforementioned long-running background process: $ sudo systemctl start docker Optionally, tell systemd to start docker on system boot: $ sudo systemctl enable docker Docker is now installed and ready for use. Check if docker is running: $ systemctl is-active docker Output: active Pull MySQL image Now that you have docker running you can pull your first image. Start with MySQL version 5.6 (without :5.6 specified, :latest is implied): $ sudo docker pull mysql:5.6 Output: 5.6: Pulling from library/mysql802b00ed6f79: Pull complete 30f19a05b898: Pull complete 3e43303be5e9: Pull complete 94b281824ae2: Pull complete 51eb397095b1: Pull complete 3f6fe5e46bae: Pull complete b5a334ca6427: Pull complete 115764d35d7a: Pull complete 719bba2efabc: Pull complete 284e66788ee1: Pull complete 0f085ade122c: Pull complete Digest: sha256:4c44f46efaff3ebe7cdc7b35a616c77aa003dc5de4b26c80d0ccae1f9db4a372Status: Downloaded newer image for mysql:5.6 Start MySQL Start the DB container, options are explained below: $ sudo docker run -d \\--name=&quot;drupal-mysql&quot; \\-e MYSQL_ROOT_PASSWORD=drupalroot \\-e MYSQL_DATABASE=drupal6 \\-e MYSQL_USER=drupal \\-e MYSQL_PASSWORD=drupal6pass \\mysql:5.6 -d — Start the container as a background process. --name —Will be referenced during Drupal install. A random name will be assigned if one isn’t provided. -e — Set’s an environment variable. MySQL will be configured with values passed in by the environment. Output (will differ): de99c912e3fbeb4f113889c145b5fab82787259c21d51962c9186e90c27d2857 Download Drupal 6 D6 is available for download from the official Drupal site packaged as a gzipped tarball. You can grab it with wget: $ cd ~$ wget https://ftp.drupal.org/files/projects/drupal-6.38.tar.gz$ tar -xzf drupal-6.38.tar.gz Verify drupal-6.38 exists in your home directory: $ if test -d ~/drupal-6.38; then echo “It exists”; fi Output: It exists Pull Apache/PHP image Now pull a docker image of Ubuntu 14.04 LTS with Apache 2, PHP 5, and Composer from https://hub.docker.com/r/nimmis/apache-php5/: $ sudo docker pull nimmis/apache-php5 Output: Using default tag: latestlatest: Pulling from nimmis/apache-php5c2c80a08aa8c: Pull complete 6ace04d7a4a2: Pull complete f03114bcfb25: Pull complete 99df43987812: Pull complete 9c646cd4d155: Pull complete 5c017123b62e: Pull complete 8f95d9abec41: Pull complete c46de42c66c3: Pull complete 9a19620cecad: Pull complete 5c62abdf642f: Pull complete Digest: sha256:712d35d5cc30e6a911e260e871f08f77d5684edcc50cba21163535714c547ff5Status: Downloaded newer image for nimmis/apache-php5:latest DocumentRoot and Incoming Port The containerized Apache’s default DocumentRoot is /var/www/html, which we will bind mount to the D6 files in ~/drupal-6.38. Because I already have Apache on the host I have to bind the container’s port 80 to something else. I’m using 10080 but you can choose almost any other free port. $ sudo docker run -d \\-p 10080:80 \\-v ~/drupal-6.38:/var/www/html \\--name=&quot;drupal-app&quot; \\--link=&quot;drupal-mysql&quot; \\nimmis/apache-php5 Output: 0398890ab8e0a082f68373c8e7fd088e925f9bac0eca178399b883091919ee77 An explanation of what’s between run and nimmis/apache-php5: -d — Daemonize, run in background. -p 10080:80 — Bind host port 10080 to container port 80. -v ~/drupal-6.38:/var/www/html — Bind host directory to container directory. — name=&quot;drupal-app&quot; — Name the container instance for convenience. --link=&quot;drupal-mysql&quot; — Link to the MySQL container so Drupal can communicate with the database. Install Drupal Open http://localhost:10080 in a browser (xdg-open is a program that will open a file or URL in the preferred application as set in your OS): $ xdg-open http://localhost:10080 Tada! The Drupal 6 installation page should be open in a browser, served from within a set of Docker containers. To complete the installation use the database name (drupal6), username (drupal), and password (drupal6pass) as set in the Start MySQL step. Under Advanced Options, set the Database host to the name of your MySQL container, drupal-mysql. Cleanup When you have finished with Drupal 6 shut down the containers and delete them from the host. Stop the containers: $ sudo docker container stop drupal-app drupal-mysql Output: drupal-appdrupal-mysql Remove the containers: $ sudo docker container rm drupal-app drupal-mysql Output: drupal-appdrupal-mysql Verify the containers have been deleted: $ sudo docker container ls That’s it, move along. Baamaapii. Bonus: docker group To display a list of groups you belong to is simple: $ group Output: roosta adm cdrom sudo dip plugdev lpadmin sambashare Add your user account to the docker group: $ sudo usermod -aG docker $USER You must log out then log back in before it takes effect.",
		date_published: "2018-10-14T00:00:00+00:00",
		date_modified: "2018-10-14T00:00:00+00:00",
		author: {
			name: "",
		},
		tags: ["drupal", "docker"],
	}, {
		id: "http://localhost:4000/github/static-site-generators/2018/09/29/scaffold-and-deploy-a-jekyll-github-pages-blog-in-5-minutes",
		url: "http://localhost:4000/github/static-site-generators/2018/09/29/scaffold-and-deploy-a-jekyll-github-pages-blog-in-5-minutes.html",
		title: "Scaffold and Deploy a Jekyll GitHub Pages Blog in 5 Minutes",
		content_html: "<p>\n  Ahnee! Static websites have made a comeback. Innovations in content generation, the adoption of Markdown in workflows,\n  deployment technology, and free hosting have made static websites an attractive option for those who don’t need the\n  capabilities of a framework or content management system.\n</p>\n<p>\n  <a href=\"https://jekyllrb.com/\">Jekyll</a> is a static site generator that made a big splash in the world of static\n  website generation. And GitHub has become the defacto standard in social coding, with\n  <a href=\"https://pages.github.com/\">GitHub Pages</a> offered as an attractive option for free static website hosting.\n</p>\n<blockquote>Jekyll is a blog-aware static site generator in Ruby</blockquote>\n<h3>My experience in static</h3>\n<p>\n  18 years ago, in my first job as a web developer, we generated and maintained static websites. The shop I worked for\n  built an in-house Perl templating “engine” which recursively crawled a directory looking for files with a custom file\n  extension to parse.\n</p>\n<p>\n  These files contained content in the form of HTML and XML-esque tags which were essentially variables that set the\n  active section in the navigation, helped generate breadcrumbs, figure out which shared content blocks to display in\n  the sidebars, etc… The meat of each file was the content for the page being generated. Using regex, the contents of a\n  master template was then populated with the contents of the parsed files then output into an html file.\n</p>\n<p>\n  The websites were generally 100+ pages and the engine wasn’t great. There was no easy way to generate a single page,\n  or a subset of pages. And it was slow. We would inevitably edit the HTML files directly when doing maintenance work.\n  Site-wide changes ended up being a scary Perl regexp which ran independently of the engine, and our master template\n  would quickly become obsolete.\n</p>\n<p>Today we have much better tooling. Written in Ruby, Jekyll is arguably the most popular static site generator.</p>\n<h3>Why develop a static website?</h3>\n<p>Why indeed. I can think of a few pros to creating and maintaining a static website.</p>\n<ul>\n  <li>\n    <strong>No server side programming required</strong><br />Creating a website usually begins with a framework. The\n    most popular software for creating websites today is Wordpress. Written in PHP, WP began as a blogging platform but\n    has since progressed to a full fledged Content Management System. A WordPress website requires a server which\n    supports PHP, which you can setup yourself or pay a hosting provider like\n    <a href=\"https://wordpress.com/\">https://wordpress.com/</a>. It’s definitely possible to create a WordPress website\n    without knowing PHP, but to customize your site, you will eventually have to get your hands dirty with a bit\n    of coding.\n  </li>\n  <li>\n    <strong>Your website will be fast</strong><br />A static web page is written in HTML and is served by a web server\n    such as Apache or Nginx. Because the HTML document does not require any additional processing, it is served directly\n    to the browser with minimal effort on the web servers part. Web servers such as Nginx are optimized for serving\n    static assets, resulting in web pages which load near instantaneously.\n  </li>\n  <li>\n    <strong>Search engines favor fast web pages<br /></strong>Google provides us with guidelines for Search Engine\n    Optimization. In 2012, Google revealed that speed is a factor in rankings.\n  </li>\n</ul>\n<h3>Tutorial</h3>\n<p>Enough talk, let’s get down to generating our new site.</p>\n<h4>Pre-requisites</h4>\n<ul>\n  <li>\n    Terminal (a command-line) —\n    <a href=\"https://linuxconfig.org/how-to-open-a-terminal-on-ubuntu-bionic-beaver-18-04-linux\"\n      >How to open Terminal on Ubuntu Bionic Beaver 18.04 Linux</a\n    >\n  </li>\n  <li>RubyGems — <a href=\"https://github.com/rvm/ubuntu_rvm\">RVM package for Ubuntu</a></li>\n  <li>\n    Git —\n    <a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-git-on-ubuntu-18-04\"\n      >How To Install Git on Ubuntu 18.04</a\n    >\n  </li>\n  <li>A GitHub account — <a href=\"https://github.com/join\">Join GitHub</a></li>\n</ul>\n<p>\n  Installing ‘gem’ and ‘git’ is out of the scope of this tutorial but the links provided above are great for Ubuntu\n  18.04. Drop me a line or comment below if you need help.\n</p>\n<h4>Create and Preview Your Site</h4>\n<p>To kick off, first you need to open a terminal and install the Jekyll ruby gem:</p>\n<blockquote>$ gem install bundler jekyll</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*o-WMlkQ2Cra6pT0O8HSeVQ.png\" /></figure>\n<p>Use jekyll to generate your awesome new site:</p>\n<blockquote>$ jekyll new my-awesome-site</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*fphO0ihPGqX8UZ8B_P-pdg.png\" /></figure>\n<p>If all went well you can use jekyll to preview your new site:</p>\n<blockquote>$ cd my-awesome-site<br />$ bundle exec jekyll serve</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*TGha9u_EC39odTSBF4nETQ.png\" /></figure>\n<blockquote>Point your browser to <a href=\"http://localhost:4000\">http://localhost:4000</a>.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iaupqu3_PhnF1iRCDlYZng.png\" /></figure>\n<blockquote>When you are finished previewing press Ctrl-C to shut down the preview server.</blockquote>\n<h3>Deploy to GitHub Pages</h3>\n<p>\n  <a href=\"https://pages.github.com/\">GitHub Pages</a> is an excellent FREE web hosting service for your GitHub\n  repositories.\n</p>\n<blockquote>\n  Websites for you and your projects.<br />Hosted directly from your GitHub repository. Just edit, push, and your\n  changes are live.\n</blockquote>\n<h4>Create a New Repository</h4>\n<p>A repository (or repo for short) is a place to manage a project and track changes to project files over time.</p>\n<blockquote>Visit <a href=\"https://github.com/new\">https://github.com/new</a></blockquote>\n<blockquote>Under “Repository name” type “my-awesome-site”</blockquote>\n<blockquote>Optionally fill in a “Description”:</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*n_waIDZ75IoaJxPdNvD0EA.png\" /></figure>\n<p>\n  Leave “Public” selected (“Private” repos are only available with paid GitHub plans), and leave all other options\n  as is.\n</p>\n<blockquote>To continue, click “Create repository”. When your repo is created you will see this screen:</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Fibe17D9cKelwO2amQP0ag.png\" /></figure>\n<p>You now have an empty repo and may continue with configuration.</p>\n<h4>Configure Repository for GitHub Pages</h4>\n<p>To link your repository to GitHub Pages you must specify which branch will be published.</p>\n<p>\n  A <a href=\"https://git-scm.com/book/en/v1/Git-Branching-What-a-Branch-Is\">git branch</a> is essentially a series of\n  snapshots of your code over time. Branching allows you, or multiple users, to modify code in an isolated work area\n  that doesn’t affect other branches or the project as a whole.\n</p>\n<p>For the purpose of this tutorial we will assign the “master” branch to be published.</p>\n<blockquote>\n  From your “my-awesome-site” repository page click the “Settings” tab which brings you to\n  <a href=\"https://github.com/jonesrussell/my-awesome-site/settings\"\n    >https://github.com/<em>username</em>/my-awesome-site/settings</a\n  >.\n</blockquote>\n<blockquote>Scroll down to “GitHub Pages” where you will see “Source” with a drop-down set to “None”.</blockquote>\n<blockquote>Click the drop-down and select “master branch”:</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uGIFFtwSc7L0-QnmKAXORA.png\" /></figure>\n<blockquote>With “master branch” selected, click “Save”.</blockquote>\n<p>\n  Once saved scroll back down to see the message “Your site is ready to be published at\n  <a href=\"https://jonesrussell.github.io/my-awesome-site/\">https://<em>username</em>.github.io/my-awesome-site/</a>.”\n</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*MQwnvC6Inb93zlev6ZuYRQ.png\" /></figure>\n<p><strong>Configure your Gemfile</strong></p>\n<p>\n  Gemfiles are used by Ruby to set the dependencies required to properly build a Ruby Gem. A Gemfile was automatically\n  generated by Jekyll in the previous steps.\n</p>\n<p>You must update your Gemfile to instruct GitHub to build your gem for deployment to GitHub Pages.</p>\n<p>Use whichever editor you are comfortable with but here I’m using “vim”:</p>\n<blockquote>$ vim Gemfile</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*Bh6_5s7-bqE7CAfAK-HyNw.png\" /></figure>\n<p>Our changes are straight-forward, simply comment out (append the line with #):</p>\n<blockquote>\n  gem “jekyll”, “~&gt; 3.8.4” (line 11 in the above screenshot; 3.8.4 is the version at the time of writing and may have\n  changed by now)\n</blockquote>\n<p>and un-comment:</p>\n<blockquote># gem “github-pages”, group: :jekyll_plugins (line 18)</blockquote>\n<p>\n  Your Gemfile should now look like the screenshot below. A ‘#’ has been appended to line 11, and the ‘#’ has been\n  removed from the beginning of line 18.\n</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*9mMkQCJzxLCmXL_I5yfm1g.png\" /></figure>\n<p>Now Save and close the Gemfile (instructions for vim):</p>\n<blockquote>:wq</blockquote>\n<p><strong>Update _config.yml</strong></p>\n<p>\n  _config.yml contains variables specific to your website. Before you deploy you may want to set the title and\n  description, and possibly your Twitter and GitHub usernames.\n</p>\n<p>\n  You must set the baseurl to ensure URLs are generated correctly, otherwise your assets and page links will not work.\n</p>\n<blockquote>$ vim _config.yml</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*9UEZoWCCdQYb4_ah0aXFKw.png\" /></figure>\n<p>Make whatever edits you like, but be sure to edit the “baseurl” (line 22) so it reads:</p>\n<blockquote>baseurl: “/my-awesome-site” # the subpath of your site, e.g. /blog</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*wku2TAwAraDwe4GCoxINHg.png\" /></figure>\n<p>Save and close.</p>\n<blockquote>:wq</blockquote>\n<p><strong>Commit Your Site Files</strong></p>\n<p>\n  You have your site files, configured for GitHub Pages, and you have an empty GitHub repository named\n  “my-awesome-site”.\n</p>\n<p>The next step is to “check-in” your files to the repo (replace <em>username</em> with your GitHub username):</p>\n<blockquote>\n  $ git init<br />$ git add .<br />$ git commit -m “first commit”<br />$ git remote add origin\n  <a href=\"https://github.com/jonesrussell/my-awesome-site.git\">https://github.com/username/my-awesome-site.git</a\n  ><br />$ git push -u origin master\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/741/1*XFr7LjpYyynfAapn9UnKlw.png\" /></figure>\n<blockquote>\n  Verify your files have been published to GitHub by visiting\n  <a href=\"https://github.com/jonesrussell/my-awesome-site\">https://github.com/<em>username</em>/my-awesome-site</a>:\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*550RFFagQa4dtiXMZkZfdw.png\" /></figure>\n<p><strong>Tada! Visit your site</strong></p>\n<p>\n  When you committed your files to the repository, GitHub automagically built a set of HTML files and deployed to\n  GitHub pages.\n</p>\n<blockquote>\n  Verify your blog is deployed by visiting\n  <a href=\"https://jonesrussell.github.io/my-awesome-site/\">https://username.github.io/my-awesome-site/</a>.\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lP_yQX0QSLepJ29IenSFjQ.png\" /></figure>\n<h3>Conclusion</h3>\n<p>\n  You are now initiated into the world of Jekyll and GitHub Pages. To create a new blog post, add a new file to the\n  “_posts” directory and check it into your repo. Be sure to examine the default post and stick to it’s naming\n  convention and the template it uses within. Once checked in visit your site and your new post should appear in the\n  homepage list.\n</p>\n<p>I hope this post was helpful, drop me a line or comment with any questions, corrections, or just to say Ahnee!</p>\n<p>Gabekana!</p>\n<img\n  src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=356a20793149\"\n  width=\"1\"\n  height=\"1\"\n/>",
		summary: "Ahnee! Static websites have made a comeback. Innovations in content generation, the adoption of Markdown in workflows, deployment technology, and free hosting have made static websites an attractive option for those who don’t need the capabilities of a framework or content management system. Jekyll is a static site generator that made a big splash in the world of static website generation. And GitHub has become the defacto standard in social coding, with GitHub Pages offered as an attractive option for free static website hosting. Jekyll is a blog-aware static site generator in Ruby My experience in static 18 years ago, in my first job as a web developer, we generated and maintained static websites. The shop I worked for built an in-house Perl templating “engine” which recursively crawled a directory looking for files with a custom file extension to parse. These files contained content in the form of HTML and XML-esque tags which were essentially variables that set the active section in the navigation, helped generate breadcrumbs, figure out which shared content blocks to display in the sidebars, etc… The meat of each file was the content for the page being generated. Using regex, the contents of a master template was then populated with the contents of the parsed files then output into an html file. The websites were generally 100+ pages and the engine wasn’t great. There was no easy way to generate a single page, or a subset of pages. And it was slow. We would inevitably edit the HTML files directly when doing maintenance work. Site-wide changes ended up being a scary Perl regexp which ran independently of the engine, and our master template would quickly become obsolete. Today we have much better tooling. Written in Ruby, Jekyll is arguably the most popular static site generator. Why develop a static website? Why indeed. I can think of a few pros to creating and maintaining a static website. No server side programming requiredCreating a website usually begins with a framework. The most popular software for creating websites today is Wordpress. Written in PHP, WP began as a blogging platform but has since progressed to a full fledged Content Management System. A WordPress website requires a server which supports PHP, which you can setup yourself or pay a hosting provider like https://wordpress.com/. It’s definitely possible to create a WordPress website without knowing PHP, but to customize your site, you will eventually have to get your hands dirty with a bit of coding. Your website will be fastA static web page is written in HTML and is served by a web server such as Apache or Nginx. Because the HTML document does not require any additional processing, it is served directly to the browser with minimal effort on the web servers part. Web servers such as Nginx are optimized for serving static assets, resulting in web pages which load near instantaneously. Search engines favor fast web pagesGoogle provides us with guidelines for Search Engine Optimization. In 2012, Google revealed that speed is a factor in rankings. Tutorial Enough talk, let’s get down to generating our new site. Pre-requisites Terminal (a command-line) — How to open Terminal on Ubuntu Bionic Beaver 18.04 Linux RubyGems — RVM package for Ubuntu Git — How To Install Git on Ubuntu 18.04 A GitHub account — Join GitHub Installing ‘gem’ and ‘git’ is out of the scope of this tutorial but the links provided above are great for Ubuntu 18.04. Drop me a line or comment below if you need help. Create and Preview Your Site To kick off, first you need to open a terminal and install the Jekyll ruby gem: $ gem install bundler jekyll Use jekyll to generate your awesome new site: $ jekyll new my-awesome-site If all went well you can use jekyll to preview your new site: $ cd my-awesome-site$ bundle exec jekyll serve Point your browser to http://localhost:4000. When you are finished previewing press Ctrl-C to shut down the preview server. Deploy to GitHub Pages GitHub Pages is an excellent FREE web hosting service for your GitHub repositories. Websites for you and your projects.Hosted directly from your GitHub repository. Just edit, push, and your changes are live. Create a New Repository A repository (or repo for short) is a place to manage a project and track changes to project files over time. Visit https://github.com/new Under “Repository name” type “my-awesome-site” Optionally fill in a “Description”: Leave “Public” selected (“Private” repos are only available with paid GitHub plans), and leave all other options as is. To continue, click “Create repository”. When your repo is created you will see this screen: You now have an empty repo and may continue with configuration. Configure Repository for GitHub Pages To link your repository to GitHub Pages you must specify which branch will be published. A git branch is essentially a series of snapshots of your code over time. Branching allows you, or multiple users, to modify code in an isolated work area that doesn’t affect other branches or the project as a whole. For the purpose of this tutorial we will assign the “master” branch to be published. From your “my-awesome-site” repository page click the “Settings” tab which brings you to https://github.com/username/my-awesome-site/settings. Scroll down to “GitHub Pages” where you will see “Source” with a drop-down set to “None”. Click the drop-down and select “master branch”: With “master branch” selected, click “Save”. Once saved scroll back down to see the message “Your site is ready to be published at https://username.github.io/my-awesome-site/.” Configure your Gemfile Gemfiles are used by Ruby to set the dependencies required to properly build a Ruby Gem. A Gemfile was automatically generated by Jekyll in the previous steps. You must update your Gemfile to instruct GitHub to build your gem for deployment to GitHub Pages. Use whichever editor you are comfortable with but here I’m using “vim”: $ vim Gemfile Our changes are straight-forward, simply comment out (append the line with #): gem “jekyll”, “~&gt; 3.8.4” (line 11 in the above screenshot; 3.8.4 is the version at the time of writing and may have changed by now) and un-comment: # gem “github-pages”, group: :jekyll_plugins (line 18) Your Gemfile should now look like the screenshot below. A ‘#’ has been appended to line 11, and the ‘#’ has been removed from the beginning of line 18. Now Save and close the Gemfile (instructions for vim): :wq Update _config.yml _config.yml contains variables specific to your website. Before you deploy you may want to set the title and description, and possibly your Twitter and GitHub usernames. You must set the baseurl to ensure URLs are generated correctly, otherwise your assets and page links will not work. $ vim _config.yml Make whatever edits you like, but be sure to edit the “baseurl” (line 22) so it reads: baseurl: “/my-awesome-site” # the subpath of your site, e.g. /blog Save and close. :wq Commit Your Site Files You have your site files, configured for GitHub Pages, and you have an empty GitHub repository named “my-awesome-site”. The next step is to “check-in” your files to the repo (replace username with your GitHub username): $ git init$ git add .$ git commit -m “first commit”$ git remote add origin https://github.com/username/my-awesome-site.git$ git push -u origin master Verify your files have been published to GitHub by visiting https://github.com/username/my-awesome-site: Tada! Visit your site When you committed your files to the repository, GitHub automagically built a set of HTML files and deployed to GitHub pages. Verify your blog is deployed by visiting https://username.github.io/my-awesome-site/. Conclusion You are now initiated into the world of Jekyll and GitHub Pages. To create a new blog post, add a new file to the “_posts” directory and check it into your repo. Be sure to examine the default post and stick to it’s naming convention and the template it uses within. Once checked in visit your site and your new post should appear in the homepage list. I hope this post was helpful, drop me a line or comment with any questions, corrections, or just to say Ahnee! Gabekana!",
		date_published: "2018-09-29T00:00:00+00:00",
		date_modified: "2018-09-29T00:00:00+00:00",
		author: {
			name: "",
		},
		tags: ["ruby", "jekyll", "github-pages", "blog"],
	},
];

posts.forEach((post) => {
	post.content_html = post.content_html.replace(/^\t{3}/gm, "");
});

export default posts;
